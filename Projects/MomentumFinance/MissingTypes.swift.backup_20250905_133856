import Foundation
import SwiftUI
import SwiftData

// MARK: - ModelContext for compatibility
#if !canImport(SwiftData)
public struct ModelContext: Sendable {
    public init() {}
}
#endif

// MARK: - Theme Types

public enum ThemeMode: String, CaseIterable, Sendable {
    case light
    case dark
    case system

    public var displayName: String {
        switch self {
        case .light: return "Light"
        case .dark: return "Dark"
        case .system: return "System"
        }
    }
    
    public var icon: String {
        switch self {
        case .light: return "sun.max"
        case .dark: return "moon"
        case .system: return "gearshape"
        }
    }
}

public struct ColorDefinitions: Sendable {
    public static let primary = Color.blue
    public static let secondary = Color.gray
    public static let accent = Color.orange
    public static let error = Color.red
    public static let warning = Color.orange
    public static let success = Color.green
    public static let info = Color.blue
    
    // Functions to match the expected interface
    public static func background(_ mode: ThemeMode) -> Color {
        switch mode {
        case .light:
            return Color.white
        case .dark:
            return Color.black
        case .system:
            return Color.primary.opacity(0.05)
        }
    }
    
    public static func surface(_ mode: ThemeMode) -> Color {
        switch mode {
        case .light:
            return Color.gray.opacity(0.1)
        case .dark:
            return Color.gray.opacity(0.2)
        case .system:
            return Color.primary.opacity(0.1)
        }
    }
    
    public static func secondaryBackground(_ mode: ThemeMode) -> Color {
        switch mode {
        case .light:
            return Color.gray.opacity(0.05)
        case .dark:
            return Color.gray.opacity(0.15)
        case .system:
            return Color.secondary.opacity(0.05)
        }
    }
    
    public static func groupedBackground(_ mode: ThemeMode) -> Color {
        switch mode {
        case .light:
            return Color(red: 0.95, green: 0.95, blue: 0.97)
        case .dark:
            return Color(red: 0.11, green: 0.11, blue: 0.12)
        case .system:
            return Color.gray.opacity(0.03)
        }
    }
    
    public static func cardBackground(_ mode: ThemeMode) -> Color {
        switch mode {
        case .light:
            return Color.white
        case .dark:
            return Color(red: 0.17, green: 0.17, blue: 0.18)
        case .system:
            return Color.primary.opacity(0.02)
        }
    }
    
    public static let categoryColors: [Color] = [
        Color.orange,   // food
        Color.blue,     // transport
        Color.purple,   // entertainment
        Color.green,    // shopping
        Color.red,      // bills
        Color.mint,     // income
        Color.teal,     // savings
        Color.gray      // other
    ]
    
    // Additional methods for complex color system
    public static func text(_ type: TextType, _ mode: ThemeMode) -> Color {
        switch (type, mode) {
        case (.primary, .light):
            return Color.black
        case (.primary, .dark):
            return Color.white
        case (.secondary, _):
            return Color.gray
        case (.tertiary, _):
            return Color.gray.opacity(0.6)
        default:
            return Color.primary
        }
    }
    
    public static func accent(_ type: AccentType, _ mode: ThemeMode) -> Color {
        switch type {
        case .primary:
            return Color.blue
        case .secondary:
            return Color.orange
        }
    }
    
    public static func financial(_ type: FinancialType, _ mode: ThemeMode) -> Color {
        switch type {
        case .income:
            return Color.green
        case .expense:
            return Color.red
        case .savings:
            return Color.blue
        case .warning:
            return Color.orange
        case .critical:
            return Color.red
        }
    }
    
    public static func budget(_ type: BudgetType, _ mode: ThemeMode) -> Color {
        switch type {
        case .under:
            return Color.green
        case .near:
            return Color.orange
        case .over:
            return Color.red
        }
    }
    
    public init() {}
}

// Supporting enums for ColorDefinitions
public enum TextType: Sendable {
    case primary, secondary, tertiary
}

public enum AccentType: Sendable {
    case primary, secondary
}

public enum FinancialType: Sendable {
    case income, expense, savings, warning, critical
}

public enum BudgetType: Sendable {
    case under, near, over
}

// MARK: - ColorTheme Extension for Demo Components
extension ColorTheme {
    public var primary: Color { accentPrimary }
    public var success: Color { income }
    public var error: Color { expense }
}

public enum DarkModePreference: String, CaseIterable, Sendable {
    case light = "light"
    case dark = "dark"
    case system = "system"
    
    public var displayName: String {
        switch self {
        case .light: return "Light"
        case .dark: return "Dark"
        case .system: return "System"
        }
    }
}

// MARK: - Transaction Types

public enum TransactionFilter: String, CaseIterable, Sendable {
    case all = "all"
    case income = "income"
    case expense = "expense"
    
    public var displayName: String {
        switch self {
        case .all: return "All"
        case .income: return "Income"
        case .expense: return "Expense"
        }
    }
}

// MARK: - Financial Insight Types

public struct FinancialInsight: Identifiable, Sendable {
    public let id = UUID()
    public let title: String
    public let description: String
    public let type: InsightType
    public let priority: InsightPriority
    public let confidence: Double
    public let value: Double?
    public let category: String?
    public let dateGenerated: Date
    public let actionable: Bool
    
    public init(
        title: String,
        description: String,
        type: InsightType,
        priority: InsightPriority,
        confidence: Double = 0.8,
        value: Double? = nil,
        category: String? = nil,
        dateGenerated: Date = Date(),
        actionable: Bool = false
    ) {
        self.title = title
        self.description = description
        self.type = type
        self.priority = priority
        self.confidence = confidence
        self.value = value
        self.category = category
        self.dateGenerated = dateGenerated
        self.actionable = actionable
    }
}

public enum InsightPriority: Int, CaseIterable, Sendable, Comparable {
    case low = 0
    case medium = 1
    case high = 2
    case urgent = 3
    
    public static func < (lhs: InsightPriority, rhs: InsightPriority) -> Bool {
        return lhs.rawValue < rhs.rawValue
    }
    
    public var color: Color {
        switch self {
        case .low: return .gray
        case .medium: return .yellow
        case .high: return .orange
        case .urgent: return .red
        }
    }
}

// MARK: - Services Protocols (Next Section)

// MARK: - Import Bridge Types (to resolve compilation order issues)

public struct ImportResult: Sendable {
    public let success: Bool
    public let transactionsImported: Int
    public let accountsImported: Int
    public let categoriesImported: Int
    public let duplicatesSkipped: Int
    public let errors: [String]
    public let warnings: [String]

    public init(
        success: Bool,
        transactionsImported: Int,
        accountsImported: Int = 0,
        categoriesImported: Int = 0,
        duplicatesSkipped: Int = 0,
        errors: [String] = [],
        warnings: [String] = []
    ) {
        self.success = success
        self.transactionsImported = transactionsImported
        self.accountsImported = accountsImported
        self.categoriesImported = categoriesImported
        self.duplicatesSkipped = duplicatesSkipped
        self.errors = errors
        self.warnings = warnings
    }
}

// MARK: - Core Data Types

public struct CSVColumnMapping: Sendable {
    public let dateColumn: String
    public let amountColumn: String
    public let descriptionColumn: String
    public let categoryColumn: String?
    public let accountColumn: String?
    
    public init(
        dateColumn: String,
        amountColumn: String,
        descriptionColumn: String,
        categoryColumn: String? = nil,
        accountColumn: String? = nil
    ) {
        self.dateColumn = dateColumn
        self.amountColumn = amountColumn
        self.descriptionColumn = descriptionColumn
        self.categoryColumn = categoryColumn
        self.accountColumn = accountColumn
    }
}

// MARK: - Navigation Types

public struct BreadcrumbItem: Identifiable, Sendable {
    public let id = UUID()
    public let title: String
    public let destination: String?
    
    public init(title: String, destination: String? = nil) {
        self.title = title
        self.destination = destination
    }
}

public struct DeepLink: Sendable {
    public let path: String
    public let parameters: [String: String]
    
    public init(path: String, parameters: [String: String] = [:]) {
        self.path = path
        self.parameters = parameters
    }
}

public enum TabSection: String, CaseIterable, Sendable {
    case dashboard = "dashboard"
    case transactions = "transactions"
    case budgets = "budgets"
    case goals = "goals"
    case insights = "insights"
    case settings = "settings"
    
    public var displayName: String {
        switch self {
        case .dashboard: return "Dashboard"
        case .transactions: return "Transactions"
        case .budgets: return "Budgets"
        case .goals: return "Goals"
        case .insights: return "Insights"
        case .settings: return "Settings"
        }
    }
}

// MARK: - Search Types

public enum SearchFilter: String, CaseIterable, Sendable {
    case all = "all"
    case transactions = "transactions"
    case accounts = "accounts"
    case budgets = "budgets"
    case goals = "goals"
    case subscriptions = "subscriptions"
    
    public var displayName: String {
        switch self {
        case .all: return "All"
        case .transactions: return "Transactions"
        case .accounts: return "Accounts"
        case .budgets: return "Budgets"
        case .goals: return "Goals"
        case .subscriptions: return "Subscriptions"
        }
    }
}

public struct SearchResult: Identifiable, Sendable {
    public let id = UUID()
    public let title: String
    public let subtitle: String?
    public let type: SearchResultType
    public let relevance: Double
    public let data: [String: String]
    
    public init(
        title: String,
        subtitle: String? = nil,
        type: SearchResultType,
        relevance: Double = 1.0,
        data: [String: String] = [:]
    ) {
        self.title = title
        self.subtitle = subtitle
        self.type = type
        self.relevance = relevance
        self.data = data
    }
}

public enum SearchResultType: String, CaseIterable, Sendable {
    case transactions = "transactions"
    case accounts = "accounts"
    case budgets = "budgets"
    case subscriptions = "subscriptions"
    case categories = "categories"
    case reports = "reports"
    case all = "all"
    
    // Compatibility cases for legacy code
    case transaction = "transaction"
    case account = "account"
    case budget = "budget"
    case subscription = "subscription"
    case category = "category"
    case report = "report"
}

// MARK: - Service Types (Simplified)

public protocol EntityManager: Sendable {
    func save() async throws
    func delete<T>(_ entity: T) async throws
    func fetch<T>(_ type: T.Type) async throws -> [T]
}

public final class DefaultEntityManager: EntityManager {
    public init() {}
    
    public func save() async throws {}
    public func delete<T>(_ entity: T) async throws {}
    public func fetch<T>(_ type: T.Type) async throws -> [T] { return [] }
}

// Temporary SearchEngineService to unblock build
// TODO: Replace with proper SearchEngineService from GlobalSearch folder
public final class SearchEngineService: ObservableObject {
    public init(modelContext: ModelContext) {}
    
    public func search(query: String, filter: SearchFilter) -> [SearchResult] {
        return []
    }
}

public final class ExportEngineService: Sendable {
    public init() {}
    
    public init(modelContext: Any) {
        // Accept any context type for compatibility
    }
    
    public func exportToCSV() async throws -> URL {
        // Simplified implementation
        return URL(fileURLWithPath: "/tmp/export.csv")
    }
    
    public func export(settings: Any) async throws -> URL {
        // Simplified export implementation
        return try await exportToCSV()
    }
    
    private func exportToJSON() async throws -> URL {
        return URL(fileURLWithPath: "/tmp/export.json")
    }
    
    private func exportToPDF() async throws -> URL {
        return URL(fileURLWithPath: "/tmp/export.pdf")
    }
}

// MARK: - Notification Manager Types

public final class NotificationPermissionManager: Sendable {
    public init(logger: Any) {}
    
    public func requestPermission() async -> Bool {
        return true
    }
    
    public func requestNotificationPermission() async -> Bool {
        return true
    }
    
    public func checkNotificationPermission(completion: @escaping (Bool) -> Void) {
        completion(true)
    }
}

public final class BudgetNotificationScheduler: Sendable {
    public init(logger: Any) {}
    
    public func scheduleNotifications() async {
        // Implementation
    }
    
    public func scheduleWarningNotifications(for budgets: [Any]) {
        // Implementation
    }
}

public final class SubscriptionNotificationScheduler: Sendable {
    public init(logger: Any) {}
    
    public func scheduleNotifications() async {
        // Implementation
    }
    
    public func scheduleNotifications(for subscriptions: [Any]) {
        // Implementation
    }
}

public final class GoalNotificationScheduler: Sendable {
    public init(logger: Any) {}
    
    public func scheduleNotifications() async {
        // Implementation
    }
    
    public func scheduleGoalNotifications(for goals: [Any]) {
        // Implementation
    }
}

// MARK: - Financial ML and Analysis Types

public final class FinancialMLModels: Sendable {
    public static let shared = FinancialMLModels()
    private init() {}
    
    public func predictSpending() async -> Double {
        return 0.0
    }
}

public final class TransactionPatternAnalyzer: Sendable {
    public static let shared = TransactionPatternAnalyzer()
    private init() {}
    
    public func analyzePatterns() async -> [String] {
        return []
    }
}

// MARK: - Animation Component Types

public struct AnimatedCardComponent {
    public struct AnimatedCard: View {
        public var body: some View {
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.gray.opacity(0.1))
        }
        
        public init() {}
    }
}

public struct AnimatedButtonComponent {
    public struct AnimatedButton: View {
        let action: () -> Void
        let label: String
        
        public var body: some View {
            Button(action: action) {
                Text(label)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
        
        public init(label: String, action: @escaping () -> Void) {
            self.label = label
            self.action = action
        }
    }
}

public struct AnimatedTransactionComponent {
    public struct AnimatedTransactionItem: View {
        public var body: some View {
            HStack {
                Circle()
                    .frame(width: 40, height: 40)
                    .foregroundColor(.blue)
                VStack(alignment: .leading) {
                    Text("Transaction")
                        .font(.headline)
                    Text("Details")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                Text("$0.00")
                    .font(.headline)
            }
            .padding()
        }
        
        public init() {}
    }
}

public struct AnimatedProgressComponents {
    public struct AnimatedBudgetProgress: View {
        let progress: Double
        
        public var body: some View {
            ProgressView(value: progress)
                .progressViewStyle(LinearProgressViewStyle())
        }
        
        public init(progress: Double) {
            self.progress = progress
        }
    }
    
    public struct AnimatedCounter: View {
        let value: Double
        
        public var body: some View {
            Text("\(value, specifier: "%.2f")")
                .font(.title)
                .fontWeight(.bold)
        }
        
        public init(value: Double) {
            self.value = value
        }
    }
}

public struct FloatingActionButtonComponent {
    public struct FloatingActionButton: View {
        let action: () -> Void
        let icon: String
        
        public var body: some View {
            Button(action: action) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(.white)
                    .frame(width: 56, height: 56)
                    .background(Color.blue)
                    .clipShape(Circle())
                    .shadow(radius: 4)
            }
        }
        
        public init(icon: String, action: @escaping () -> Void) {
            self.icon = icon
            self.action = action
        }
    }
}

// MARK: - Import UI Components

public struct DataImportHeaderComponent: View {
    public var body: some View {
        VStack(spacing: 12) {
            Image(systemName: "square.and.arrow.down")
                .font(.system(size: 48))
                .foregroundColor(.blue)
            
            Text("Import Financial Data")
                .font(.title2)
                .fontWeight(.semibold)
            
            Text("Import transactions from CSV files")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .padding()
    }
    
    public init() {}
}

public struct FileSelectionComponent: View {
    @Binding public var showingFilePicker: Bool
    public let onFileSelected: () -> Void
    
    public var body: some View {
        VStack(spacing: 16) {
            Button(action: {
                showingFilePicker = true
                onFileSelected()
            }) {
                VStack(spacing: 12) {
                    Image(systemName: "doc.badge.plus")
                        .font(.system(size: 32))
                    Text("Select CSV File")
                        .font(.headline)
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue.opacity(0.1))
                .foregroundColor(.blue)
                .cornerRadius(12)
            }
        }
        .padding()
    }
    
    public init(showingFilePicker: Binding<Bool>, onFileSelected: @escaping () -> Void) {
        self._showingFilePicker = showingFilePicker
        self.onFileSelected = onFileSelected
    }
}

public struct ImportProgressComponent: View {
    public let progress: Double
    
    public var body: some View {
        VStack(spacing: 8) {
            Text("Importing...")
                .font(.headline)
            
            ProgressView(value: progress)
                .progressViewStyle(LinearProgressViewStyle())
            
            Text("\(Int(progress * 100))% Complete")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
    }
    
    public init(progress: Double) {
        self.progress = progress
    }
}

public struct ImportButtonComponent: View {
    public let isImporting: Bool
    public let action: () -> Void
    
    public var body: some View {
        Button(action: action) {
            HStack {
                if isImporting {
                    ProgressView()
                        .scaleEffect(0.8)
                }
                Text(isImporting ? "Importing..." : "Import Data")
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(isImporting ? Color.gray : Color.blue)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
        .disabled(isImporting)
    }
    
    public init(isImporting: Bool, action: @escaping () -> Void) {
        self.isImporting = isImporting
        self.action = action
    }
}

public struct ImportInstructionsComponent: View {
    public var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Import Instructions")
                .font(.headline)
            
            VStack(alignment: .leading, spacing: 8) {
                instructionRow("1.", "Prepare a CSV file with your transaction data")
                instructionRow("2.", "Include columns: Date, Amount, Description")
                instructionRow("3.", "Optional: Category, Account columns")
                instructionRow("4.", "Select your file and click Import")
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    private func instructionRow(_ number: String, _ text: String) -> some View {
        HStack(alignment: .top, spacing: 8) {
            Text(number)
                .fontWeight(.semibold)
                .foregroundColor(.blue)
            Text(text)
                .foregroundColor(.secondary)
            Spacer()
        }
    }
    
    public init() {}
}

// MARK: - Import Result View

public struct ImportResultView: View {
    public let result: ImportResult
    public let onDismiss: () -> Void
    
    public var body: some View {
        VStack(spacing: 16) {
            // Success/Error Icon
            Image(systemName: result.success ? "checkmark.circle.fill" : "xmark.circle.fill")
                .font(.system(size: 48))
                .foregroundColor(result.success ? .green : .red)
            
            // Title
            Text(result.success ? "Import Successful!" : "Import Failed")
                .font(.title2)
                .fontWeight(.semibold)
            
            // Message
            Text(result.success ? "Import completed successfully" : "Import failed")
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            // Statistics (if successful)
            if result.success && result.transactionsImported > 0 {
                VStack(spacing: 8) {
                    HStack {
                        Text("Imported:")
                        Spacer()
                        Text("\(result.transactionsImported)")
                            .fontWeight(.semibold)
                    }
                    
                    if result.duplicatesSkipped > 0 {
                        HStack {
                            Text("Skipped:")
                            Spacer()
                            Text("\(result.duplicatesSkipped)")
                                .fontWeight(.semibold)
                        }
                    }
                    
                    if result.errorCount > 0 {
                        HStack {
                            Text("Errors:")
                            Spacer()
                            Text("\(result.errorCount)")
                                .fontWeight(.semibold)
                                .foregroundColor(.red)
                        }
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(8)
            }
            
            // Dismiss Button
            Button("Close") {
                onDismiss()
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(16)
        .shadow(radius: 10)
    }
    
    public init(result: ImportResult, onDismiss: @escaping () -> Void) {
        self.result = result
        self.onDismiss = onDismiss
    }
}

// MARK: - Theme Demo Components

public struct ThemeSelectorCard: View {
    @Binding public var selectedThemeMode: ThemeMode
    public let theme: Any?
    
    public init(selectedThemeMode: Binding<ThemeMode>, theme: Any? = nil) {
        self._selectedThemeMode = selectedThemeMode
        self.theme = theme
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Theme Selection")
                .font(.headline)
                .fontWeight(.semibold)
            
            HStack(spacing: 12) {
                ForEach(ThemeMode.allCases, id: \.self) { mode in
                    Button(action: {
                        selectedThemeMode = mode
                    }) {
                        VStack(spacing: 8) {
                            Image(systemName: themeIcon(for: mode))
                                .font(.title2)
                            Text(mode.displayName)
                                .font(.caption)
                        }
                        .padding()
                        .background(selectedThemeMode == mode ? Color.blue : Color.gray.opacity(0.2))
                        .foregroundColor(selectedThemeMode == mode ? .white : .primary)
                        .cornerRadius(8)
                    }
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    private func themeIcon(for mode: ThemeMode) -> String {
        switch mode {
        case .light: return "sun.max"
        case .dark: return "moon"
        case .system: return "gearshape"
        }
    }
    
    public init(selectedThemeMode: Binding<ThemeMode>) {
        self._selectedThemeMode = selectedThemeMode
    }
}

public struct ThemeFinancialSummaryCard: View {
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Financial Summary")
                .font(.headline)
                .fontWeight(.semibold)
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Total Balance")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("$12,345.67")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.blue)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("This Month")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("+$1,234.56")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.green)
                }
            }
            
            Divider()
            
            HStack {
                Text("Spending")
                    .foregroundColor(.secondary)
                Spacer()
                Text("$2,345.89")
                    .fontWeight(.semibold)
                    .foregroundColor(.red)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    public init(theme: Any = ()) {
        // Accept any theme parameter for compatibility but use static colors
    }
}

public struct ThemeAccountsList: View {
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Accounts")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(spacing: 8) {
                accountRow("Checking", "$3,456.78")
                accountRow("Savings", "$8,888.89")
                accountRow("Credit Card", "-$567.12")
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    private func accountRow(_ name: String, _ balance: String) -> some View {
        HStack {
            Circle()
                .fill(Color.blue)
                .frame(width: 32, height: 32)
                .overlay(
                    Text(String(name.prefix(1)))
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                )
            
            VStack(alignment: .leading, spacing: 2) {
                Text(name)
                    .font(.subheadline)
                    .fontWeight(.medium)
                Text("Account")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Text(balance)
                .font(.subheadline)
                .fontWeight(.semibold)
                .foregroundColor(balance.hasPrefix("-") ? .red : .blue)
        }
        .padding(.vertical, 4)
    }
    
    public init(theme: Any = ()) {
        // Accept any theme parameter for compatibility but use static colors
    }
}

// MARK: - Insights Views

public struct InsightsLoadingView: View {
    public var body: some View {
        VStack(spacing: 16) {
            ProgressView()
                .scaleEffect(1.2)
            Text("Loading insights...")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.gray.opacity(0.1))
    }
    
    public init() {}
}

public struct InsightsEmptyStateView: View {
    public var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "chart.line.uptrend.xyaxis")
                .font(.system(size: 48))
                .foregroundColor(.gray)
            
            Text("No Insights Available")
                .font(.headline)
                .fontWeight(.semibold)
            
            Text("Add some transactions to see personalized insights about your spending patterns.")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.gray.opacity(0.1))
    }
    
    public init() {}
}

public struct InsightRowView: View {
    public let insight: FinancialInsight
    public let action: () -> Void
    
    public var body: some View {
        HStack(spacing: 12) {
            // Priority indicator
            Circle()
                .fill(priorityColor(insight.priority))
                .frame(width: 8, height: 8)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(insight.title)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .lineLimit(2)
                
                Text(insight.description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(3)
            }
            
            Spacer()
            
            // Show confidence as percentage
            Text("\(Int(insight.confidence * 100))%")
                .font(.caption)
                .fontWeight(.semibold)
                .foregroundColor(.blue)
        }
        .padding(.vertical, 8)
        .contentShape(Rectangle())
        .onTapGesture {
            action()
        }
    }
    
    private func priorityColor(_ priority: InsightPriority) -> Color {
        switch priority {
        case .low:
            return .gray
        case .medium:
            return .yellow
        case .high:
            return .orange
        case .urgent:
            return .red
        }
    }
    
    public init(insight: FinancialInsight, action: @escaping () -> Void) {
        self.insight = insight
        self.action = action
    }
}

// MARK: - Insight Data Model

public struct Insight: Identifiable, Sendable {
    public let id = UUID()
    public let title: String
    public let description: String
    public let value: String?
    public let priority: InsightPriority
    public let category: String?
    public let dateCreated: Date
    
    public init(
        title: String,
        description: String,
        value: String? = nil,
        priority: InsightPriority = .medium,
        category: String? = nil,
        dateCreated: Date = Date()
    ) {
        self.title = title
        self.description = description
        self.value = value
        self.priority = priority
        self.category = category
        self.dateCreated = dateCreated
    }
}

// MARK: - Additional Insights Views

public struct InsightsFilterBar: View {
    @Binding public var filterPriority: InsightPriority?
    @Binding public var filterType: InsightType?
    
    public var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                FilterChip(title: "All", isSelected: filterPriority == nil && filterType == nil) {
                    filterPriority = nil
                    filterType = nil
                }
                
                FilterChip(title: "High Priority", isSelected: filterPriority == .high) {
                    filterPriority = filterPriority == .high ? nil : .high
                }
                
                FilterChip(title: "Urgent", isSelected: filterPriority == .urgent) {
                    filterPriority = filterPriority == .urgent ? nil : .urgent
                }
                
                FilterChip(title: "Spending", isSelected: filterType == .spendingPattern) {
                    filterType = filterType == .spendingPattern ? nil : .spendingPattern
                }
                
                FilterChip(title: "Budget", isSelected: filterType == .budgetAlert) {
                    filterType = filterType == .budgetAlert ? nil : .budgetAlert
                }
            }
            .padding(.horizontal)
        }
    }
    
    public init(filterPriority: Binding<InsightPriority?>, filterType: Binding<InsightType?>) {
        self._filterPriority = filterPriority
        self._filterType = filterType
    }
}

public struct FilterChip: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    public var body: some View {
        Button(action: action) {
            Text(title)
                .font(.caption)
                .fontWeight(.medium)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(isSelected ? Color.blue : Color.gray.opacity(0.2))
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(16)
        }
    }
    
    public init(title: String, isSelected: Bool, action: @escaping () -> Void) {
        self.title = title
        self.isSelected = isSelected
        self.action = action
    }
}

public struct InsightDetailView: View {
    public let insight: FinancialInsight
    @Environment(\.dismiss) private var dismiss
    
    public var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Header
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Circle()
                                .fill(priorityColor(insight.priority))
                                .frame(width: 12, height: 12)
                            
                            Text(priorityText(insight.priority))
                                .font(.caption)
                                .fontWeight(.medium)
                                .foregroundColor(.secondary)
                        }
                        
                        Text(insight.title)
                            .font(.title2)
                            .fontWeight(.bold)
                    }
                    
                    // Confidence
                    Text("Confidence: \(Int(insight.confidence * 100))%")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.blue)
                    
                    // Description
                    Text(insight.description)
                        .font(.body)
                        .foregroundColor(.secondary)
                    
                    // Type info
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Insight Type")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.secondary)
                        
                        Text(insight.type.rawValue.capitalized)
                            .font(.subheadline)
                            .padding(.horizontal, 12)
                            .padding(.vertical, 6)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(8)
                    }
                    
                    Spacer()
                }
                .padding()
            }
            .navigationTitle("Insight Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
    
    private func priorityColor(_ priority: InsightPriority) -> Color {
        switch priority {
        case .low: return .gray
        case .medium: return .yellow
        case .high: return .orange
        case .urgent: return .red
        }
    }
    
    private func priorityText(_ priority: InsightPriority) -> String {
        switch priority {
        case .low: return "Low Priority"
        case .medium: return "Medium Priority"
        case .high: return "High Priority"
        case .urgent: return "Urgent"
        }
    }
    
    public init(insight: FinancialInsight) {
        self.insight = insight
    }
}

// MARK: - Notification Support

/// Represents a scheduled notification with its metadata
public struct ScheduledNotification: Identifiable, Sendable {
    public let id: String
    public let title: String
    public let body: String
    public let type: String
    public let scheduledDate: Date?

    public init(id: String, title: String, body: String, type: String, scheduledDate: Date?) {
        self.id = id
        self.title = title
        self.body = body
        self.type = type
        self.scheduledDate = scheduledDate
    }
}

// MARK: - Insight Types Support

public enum InsightType: String, CaseIterable, Sendable {
    case spendingPattern
    case positiveSpendingTrend
    case anomaly
    case budgetAlert
    case budgetInsight
    case budgetRecommendation
    case subscriptionDetection
    case forecast
    case optimization

    /// System icon for the insight type
    public var icon: String {
        switch self {
        case .spendingPattern:
            return "chart.line.uptrend.xyaxis"
        case .positiveSpendingTrend:
            return "arrow.down.circle"
        case .anomaly:
            return "exclamationmark.triangle"
        case .budgetAlert:
            return "chart.pie.fill"
        case .budgetInsight:
            return "chart.bar.fill"
        case .budgetRecommendation:
            return "plus.circle"
        case .subscriptionDetection:
            return "calendar.badge.clock"
        case .forecast:
            return "chart.xyaxis.line"
        case .optimization:
            return "bolt.circle"
        }
    }
}

// MARK: - Notification Service Extensions

extension NotificationPermissionManager {
    public func checkNotificationPermission() async -> Bool {
        let settings = await UNUserNotificationCenter.current().notificationSettings()
        return settings.authorizationStatus == .authorized
    }
}

extension BudgetNotificationScheduler {
    public func scheduleWarningNotifications() {
        // Placeholder for budget warning scheduling
        print("Scheduling budget warning notifications")
    }
}

extension GoalNotificationScheduler {
    public func checkMilestones(for goals: [SavingsGoal]) {
        // Placeholder for goal milestone checking
        print("Checking goal milestones for \(goals.count) goals")
    }
}

extension SubscriptionNotificationScheduler {
    public func scheduleNotifications(for subscriptions: [Subscription]) {
        // Placeholder for subscription notification scheduling
        print("Scheduling notifications for \(subscriptions.count) subscriptions")
    }
}



// MARK: - Data Import Support

extension CSVColumnMapping {
    public var notesIndex: Int? {
        // Return a default notes column index or nil
        return nil
    }
}

// MARK: - Financial Intelligence Functions

func fi_generateForecasts(transactions: [Any], accounts: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

func fi_analyzeSpendingPatterns(transactions: [Any], categories: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

func fi_detectAnomalies(transactions: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

func fi_analyzeBudgets(transactions: [Any], budgets: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

func fi_suggestIdleCashInsights(transactions: [Any], accounts: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

func fi_suggestCreditUtilizationInsights(accounts: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

func fi_suggestDuplicatePaymentInsights(transactions: [Any]) -> [FinancialInsight] {
    // Placeholder implementation
    return []
}

// MARK: - Financial ML Models Extension

extension FinancialMLModels {
    func suggestCategoryForTransaction(_ transaction: Any) -> ExpenseCategory? {
        // Placeholder implementation
        return nil
    }
}

// MARK: - Forecast Data Model

public struct ForecastData: Identifiable, Sendable {
    public let id = UUID()
    public let date: Date
    public let predictedBalance: Double
    public let confidence: Double
    
    public init(date: Date, predictedBalance: Double, confidence: Double) {
        self.date = date
        self.predictedBalance = predictedBalance
        self.confidence = confidence
    }
}

// MARK: - Search Components

public struct SearchHeaderComponent: View {
    @Binding public var searchText: String
    @Binding public var selectedFilter: SearchFilter
    public let onSearchChanged: () -> Void
    
    public var body: some View {
        VStack(spacing: 12) {
            TextField("Search transactions, accounts...", text: $searchText)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .onChange(of: searchText) {
                    onSearchChanged()
                }
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack {
                    ForEach(SearchFilter.allCases, id: \.self) { filter in
                        Button(filter.rawValue.capitalized) {
                            selectedFilter = filter
                            onSearchChanged()
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(selectedFilter == filter ? Color.blue : Color.gray.opacity(0.2))
                        .foregroundColor(selectedFilter == filter ? .white : .primary)
                        .cornerRadius(16)
                    }
                }
                .padding(.horizontal)
            }
        }
        .padding()
    }
    
    public init(
        searchText: Binding<String>,
        selectedFilter: Binding<SearchFilter>,
        onSearchChanged: @escaping () -> Void
    ) {
        self._searchText = searchText
        self._selectedFilter = selectedFilter
        self.onSearchChanged = onSearchChanged
    }
}

public struct SearchResultsComponent: View {
    public let results: [SearchResult]
    public let isLoading: Bool
    public let onResultTapped: (SearchResult) -> Void
    
    public var body: some View {
        Group {
            if isLoading {
                ProgressView("Searching...")
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if results.isEmpty {
                VStack {
                    Image(systemName: "magnifyingglass")
                        .font(.system(size: 48))
                        .foregroundColor(.gray)
                    Text("No results found")
                        .font(.headline)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                LazyVStack(spacing: 8) {
                    ForEach(results) { result in
                        SearchResultRow(result: result) {
                            onResultTapped(result)
                        }
                    }
                }
                .padding()
            }
        }
    }
    
    public init(
        results: [SearchResult],
        isLoading: Bool,
        onResultTapped: @escaping (SearchResult) -> Void
    ) {
        self.results = results
        self.isLoading = isLoading
        self.onResultTapped = onResultTapped
    }
}

public struct SearchResultRow: View {
    public let result: SearchResult
    public let action: () -> Void
    
    public var body: some View {
        Button(action: action) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(result.title)
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Text(result.subtitle ?? "")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Text(result.type.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.1))
                    .foregroundColor(.blue)
                    .cornerRadius(8)
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    public init(result: SearchResult, action: @escaping () -> Void) {
        self.result = result
        self.action = action
    }
}

public struct SearchConfiguration: Sendable {
    public let maxResults: Int
    public let includeAccounts: Bool
    public let includeTransactions: Bool
    public let includeBudgets: Bool
    public let searchDebounceDelay: Double
    
    public static let shared = SearchConfiguration()
    
    public init(
        maxResults: Int = 50,
        includeAccounts: Bool = true,
        includeTransactions: Bool = true,
        includeBudgets: Bool = true,
        searchDebounceDelay: Double = 0.5
    ) {
        self.maxResults = maxResults
        self.includeAccounts = includeAccounts
        self.includeTransactions = includeTransactions
        self.includeBudgets = includeBudgets
        self.searchDebounceDelay = searchDebounceDelay
    }
}

// MARK: - Transaction View Components

public struct TransactionEmptyStateView: View {
    public let searchText: String
    public let onAddTransaction: () -> Void
    
    public var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "dollarsign.circle")
                .font(.system(size: 64))
                .foregroundColor(.gray)
            
            Text(searchText.isEmpty ? "No Transactions" : "No Results")
                .font(.title2)
                .fontWeight(.semibold)
            
            Text(searchText.isEmpty 
                 ? "Start tracking your finances by adding your first transaction"
                 : "No transactions match your search criteria")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
                
            if searchText.isEmpty {
                Button("Add Transaction") {
                    onAddTransaction()
                }
                .buttonStyle(.borderedProminent)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    public init(searchText: String, onAddTransaction: @escaping () -> Void) {
        self.searchText = searchText
        self.onAddTransaction = onAddTransaction
    }
}

public struct TransactionListView: View {
    public let transactions: [FinancialTransaction]
    public let onTransactionTapped: (FinancialTransaction) -> Void
    public let onDeleteTransaction: (FinancialTransaction) -> Void
    
    public var body: some View {
        LazyVStack(spacing: 8) {
            ForEach(0..<transactions.count, id: \.self) { index in
                TransactionRowView(
                    transaction: transactions[index],
                    onTap: { onTransactionTapped(transactions[index]) },
                    onDelete: { onDeleteTransaction(transactions[index]) }
                )
            }
        }
        .padding(.horizontal)
    }
    
    public init(
        transactions: [FinancialTransaction], 
        onTransactionTapped: @escaping (FinancialTransaction) -> Void,
        onDeleteTransaction: @escaping (FinancialTransaction) -> Void
    ) {
        self.transactions = transactions
        self.onTransactionTapped = onTransactionTapped
        self.onDeleteTransaction = onDeleteTransaction
    }
}

public struct TransactionRowView: View {
    public let transaction: FinancialTransaction
    public let onTap: () -> Void
    public let onDelete: (() -> Void)?
    
    public var body: some View {
        HStack(spacing: 12) {
            // Transaction icon
            Circle()
                .fill(Color.blue)
                .frame(width: 40, height: 40)
                .overlay(
                    Image(systemName: "creditcard")
                        .font(.system(size: 16))
                        .foregroundColor(.white)
                )
            
            VStack(alignment: .leading, spacing: 2) {
                Text(transaction.title)
                    .font(.subheadline)
                    .fontWeight(.medium)
                
                Text("\(transaction.category?.name ?? "Category")  Today")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Text("$\(transaction.amount, specifier: "%.2f")")
                .font(.subheadline)
                .fontWeight(.semibold)
        }
        .padding(.vertical, 8)
        .padding(.horizontal, 12)
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
        .onTapGesture(perform: onTap)
        .swipeActions(edge: .trailing) {
            if let onDelete = onDelete {
                Button("Delete", role: .destructive) {
                    onDelete()
                }
            }
        }
    }
    
    public init(transaction: FinancialTransaction, onTap: @escaping () -> Void, onDelete: (() -> Void)? = nil) {
        self.transaction = transaction
        self.onTap = onTap
        self.onDelete = onDelete
    }
}

public struct AddTransactionView: View {
    public let categories: [Any]
    public let accounts: [Any]
    @Environment(\.dismiss) private var dismiss
    
    public var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text("Add Transaction")
                    .font(.title2)
                    .fontWeight(.semibold)
                
                Text("Categories: \(categories.count), Accounts: \(accounts.count)")
                    .foregroundColor(.secondary)
                
                Text("Transaction form would go here")
                    .foregroundColor(.secondary)
                
                Spacer()
            }
            .padding()
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        dismiss()
                    }
                    .fontWeight(.semibold)
                }
            }
        }
    }
    
    public init(categories: [Any], accounts: [Any]) {
        self.categories = categories
        self.accounts = accounts
    }
}

public struct TransactionDetailView: View {
    public let transaction: Any
    @Environment(\.dismiss) private var dismiss
    
    public var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Transaction header
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Transaction Details")
                            .font(.title2)
                            .fontWeight(.bold)
                        
                        Text("$0.00")
                            .font(.title)
                            .fontWeight(.semibold)
                            .foregroundColor(.blue)
                    }
                    
                    // Transaction info
                    VStack(alignment: .leading, spacing: 12) {
                        detailRow("Category", "General")
                        detailRow("Date", "Today")
                        detailRow("Account", "Checking")
                        detailRow("Description", "Transaction details")
                    }
                    
                    Spacer()
                }
                .padding()
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
    
    private func detailRow(_ label: String, _ value: String) -> some View {
        HStack {
            Text(label)
                .fontWeight(.medium)
                .foregroundColor(.secondary)
            
            Spacer()
            
            Text(value)
                .fontWeight(.medium)
        }
        .padding(.vertical, 4)
    }
    
    public init(transaction: Any) {
        self.transaction = transaction
    }
}

public struct TransactionStatsCard: View {
    public let transactions: [Any]
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Transaction Stats")
                .font(.headline)
                .fontWeight(.semibold)
            
            HStack {
                VStack(alignment: .leading) {
                    Text("This Month")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("$0.00")
                        .font(.title3)
                        .fontWeight(.bold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Transactions")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(transactions.count)")
                        .font(.title3)
                        .fontWeight(.bold)
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
    
    public init(transactions: [Any]) {
        self.transactions = transactions
    }
}

public struct SearchAndFilterSection: View {
    @Binding public var searchText: String
    @Binding public var selectedFilter: TransactionFilter
    @Binding public var showingSearch: Bool
    
    public var body: some View {
        VStack(spacing: 12) {
            // Search bar
            HStack {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(.secondary)
                
                TextField("Search transactions...", text: $searchText)
                    .textFieldStyle(PlainTextFieldStyle())
                
                Button(action: { showingSearch = true }) {
                    Image(systemName: "line.horizontal.3.decrease.circle")
                        .foregroundColor(.blue)
                }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            .background(Color.gray.opacity(0.1))
            .cornerRadius(8)
            
            // Filter chips
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(TransactionFilter.allCases, id: \.self) { filter in
                        filterChip(filter.displayName, selectedFilter == filter, filter)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
    
    private func filterChip(_ title: String, _ isSelected: Bool, _ filter: TransactionFilter) -> some View {
        Button(action: {
            selectedFilter = filter
        }) {
            Text(title)
                .font(.caption)
                .fontWeight(.medium)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(isSelected ? Color.blue : Color.gray.opacity(0.2))
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(16)
        }
    }
    
    public init(
        searchText: Binding<String>, 
        selectedFilter: Binding<TransactionFilter>,
        showingSearch: Binding<Bool>
    ) {
        self._searchText = searchText
        self._selectedFilter = selectedFilter
        self._showingSearch = showingSearch
    }
}

// MARK: - Data Import Support Types

public struct ImportValidator {
    public static func validateRequiredFields(fields: [String], columnMapping: CSVColumnMapping) throws {
        // Basic validation
        if fields.isEmpty {
            throw ImportError.missingRequiredField("No fields provided")
        }
    }
    
    public static func validateCSVFormat(content: String) throws -> [String] {
        // Basic CSV format validation
        if content.isEmpty {
            throw ImportError.invalidFormat("Empty CSV content")
        }
        let lines = content.components(separatedBy: .newlines)
        return lines.first?.components(separatedBy: ",") ?? []
    }
    
    public func isDuplicate(_ transaction: Any) async throws -> Bool {
        // Mock implementation
        return false
    }
}

public struct CSVParser {
    public static func parseCSV(from url: URL) throws -> [[String]] {
        let content = try String(contentsOf: url, encoding: .utf8)
        return content.components(separatedBy: .newlines)
            .map { $0.components(separatedBy: ",") }
    }
    
    public static func parseCSVRow(_ row: String) -> [String] {
        return row.components(separatedBy: ",")
    }
    
    public static func mapColumns(headers: [String]) -> CSVColumnMapping {
        // Mock implementation
        return CSVColumnMapping(
            dateColumn: "Date",
            amountColumn: "Amount",
            descriptionColumn: "Description",
            categoryColumn: "Category",
            accountColumn: "Account"
        )
    }
}

public struct DataParser {
    public static func parseDate(_ dateString: String) throws -> Date {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        if let date = formatter.date(from: dateString) {
            return date
        }
        formatter.dateFormat = "MM/dd/yyyy"
        if let date = formatter.date(from: dateString) {
            return date
        }
        throw ImportError.invalidFormat("Invalid date format: \(dateString)")
    }
    
    public static func parseAmount(_ amountString: String) throws -> Double {
        let cleanString = amountString.replacingOccurrences(of: "$", with: "")
                                    .replacingOccurrences(of: ",", with: "")
        guard let amount = Double(cleanString) else {
            throw ImportError.invalidAmountFormat("Invalid amount: \(amountString)")
        }
        return amount
    }
    
    public static func parseTransactionType(_ typeString: String, amount: Double) -> TransactionType {
        if typeString.contains("income") || typeString.contains("deposit") {
            return .income
        } else if typeString.contains("expense") || typeString.contains("withdrawal") {
            return .expense
        } else {
            return amount >= 0 ? .income : .expense
        }
    }
}

// Add missing properties to CSVColumnMapping
extension CSVColumnMapping {
    public var dateIndex: Int? { return 0 }
    public var titleIndex: Int? { return 1 }
    public var amountIndex: Int? { return 2 }
    public var typeIndex: Int? { return 3 }
}

// Add missing methods to EntityManager
public extension EntityManager {
    func getOrCreateAccount(from fields: [String], columnMapping: CSVColumnMapping) async throws -> FinancialAccount? {
        // Mock implementation
        return nil
    }
    
    func getOrCreateCategory(from fields: [String], columnMapping: CSVColumnMapping, transactionType: Any) async throws -> ExpenseCategory? {
        // Mock implementation
        return nil
    }
}

// MARK: - Missing Theme Components

public struct ThemeBudgetProgress: View {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public var body: some View {
        Text("Budget Progress")
    }
}

public struct ThemeSubscriptionsList: View {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public var body: some View {
        Text("Subscriptions List")
    }
}

public struct ThemeTypographyShowcase: View {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public var body: some View {
        Text("Typography Showcase")
    }
}

public struct ThemeButtonStylesShowcase: View {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public var body: some View {
        Text("Button Styles Showcase")
    }
}

public struct ThemeSettingsSheet: View {
    @Binding public var selectedThemeMode: ThemeMode
    @Binding public var sliderValue: Double
    @Binding public var showSheet: Bool
    public let theme: Any?
    
    public init(selectedThemeMode: Binding<ThemeMode>, sliderValue: Binding<Double>, showSheet: Binding<Bool>, theme: Any? = nil) {
        self._selectedThemeMode = selectedThemeMode
        self._sliderValue = sliderValue
        self._showSheet = showSheet
        self.theme = theme
    }
    
    public var body: some View {
        NavigationView {
            VStack {
                Text("Theme Settings")
                Slider(value: $sliderValue, in: 0...1)
                Button("Close") {
                    showSheet = false
                }
            }
            .navigationTitle("Settings")
        }
    }
}

// MARK: - Missing Button Styles

public struct PrimaryButtonStyle: ButtonStyle {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding()
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(8)
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
    }
}

public struct SecondaryButtonStyle: ButtonStyle {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding()
            .background(Color.gray.opacity(0.2))
            .foregroundColor(.primary)
            .cornerRadius(8)
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
    }
}

public struct TextButtonStyle: ButtonStyle {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(.horizontal)
            .foregroundColor(.blue)
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
    }
}

public struct DestructiveButtonStyle: ButtonStyle {
    public let theme: Any?
    
    public init(theme: Any? = nil) {
        self.theme = theme
    }
    
    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding()
            .background(Color.red)
            .foregroundColor(.white)
            .cornerRadius(8)
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
    }
}

// MARK: - Missing Utility Functions

public func formatCurrency(_ amount: Double) -> String {
    let formatter = NumberFormatter()
    formatter.numberStyle = .currency
    formatter.currencyCode = "USD"
    return formatter.string(from: NSNumber(value: amount)) ?? "$0.00"
}

// MARK: - Missing Features.Transactions Components

extension Features.Transactions {
    struct AddTransactionView: View {
        public let categories: [ExpenseCategory]
        public let accounts: [FinancialAccount]
        
        public init(categories: [ExpenseCategory], accounts: [FinancialAccount]) {
            self.categories = categories
            self.accounts = accounts
        }
        
        public var body: some View {
            VStack {
                Text("Add Transaction")
                    .font(.title)
                
                Text("Categories: \(categories.count)")
                Text("Accounts: \(accounts.count)")
                
                Button("Save Transaction") {
                    // Save logic
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
        }
    }
}

public struct SecuritySettingsSection: View {
    @Binding public var biometricEnabled: Bool
    public let authenticationTimeout: Any
    
    public init(biometricEnabled: Binding<Bool>, authenticationTimeout: Any) {
        self._biometricEnabled = biometricEnabled
        self.authenticationTimeout = authenticationTimeout
    }
    
    public var body: some View {
        Section("Security") {
            Text("Security settings placeholder")
        }
    }
}

public struct AccessibilitySettingsSection: View {
    @Binding public var hapticFeedbackEnabled: Bool
    @Binding public var reducedMotion: Bool
    
    public init(hapticFeedbackEnabled: Binding<Bool>, reducedMotion: Binding<Bool>) {
        self._hapticFeedbackEnabled = hapticFeedbackEnabled
        self._reducedMotion = reducedMotion
    }
    
    public var body: some View {
        Section("Accessibility") {
            Text("Accessibility settings placeholder")
        }
    }
}

public struct AppearanceSettingsSection: View {
    public let darkModePreference: Any
    
    public init(darkModePreference: Any) {
        self.darkModePreference = darkModePreference
    }
    
    public var body: some View {
        Section("Appearance") {
            Text("Appearance settings placeholder")
        }
    }
}

public struct DataManagementSection: View {
    @Binding public var dataRetentionDays: Double
    @Binding public var showingDeleteConfirmation: Bool
    @Binding public var hapticFeedbackEnabled: Bool
    
    public init(dataRetentionDays: Binding<Double>, showingDeleteConfirmation: Binding<Bool>, hapticFeedbackEnabled: Binding<Bool>) {
        self._dataRetentionDays = dataRetentionDays
        self._showingDeleteConfirmation = showingDeleteConfirmation
        self._hapticFeedbackEnabled = hapticFeedbackEnabled
    }
    
    public var body: some View {
        Section("Data Management") {
            Text("Data management placeholder")
        }
    }
}

public struct ImportExportSection: View {
    public let importManager: Any?
    public let modelContext: Any?
    
    public init(importManager: Any? = nil, modelContext: Any? = nil) {
        self.importManager = importManager
        self.modelContext = modelContext
    }
    
    public var body: some View {
        Section("Import/Export") {
            Text("Import/Export placeholder")
        }
    }
}

public struct AboutSection: View {
    public init() {}
    
    public var body: some View {
        Section("About") {
            Text("About placeholder")
        }
    }
}

// MARK: - Features Namespace Extensions

extension Features.Transactions {
    public struct TransactionRowView: View {
        public let transaction: FinancialTransaction
        public let onTapped: () -> Void
        
        public init(transaction: FinancialTransaction, onTapped: @escaping () -> Void) {
            self.transaction = transaction
            self.onTapped = onTapped
        }
        
        public var body: some View {
            HStack(spacing: 12) {
                // Transaction icon
                Circle()
                    .fill(Color.blue)
                    .frame(width: 40, height: 40)
                    .overlay(
                        Image(systemName: "creditcard")
                            .font(.system(size: 16))
                            .foregroundColor(.white)
                    )
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(transaction.title)
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    Text("\(transaction.category?.name ?? "Category")  Today")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Text("$\(transaction.amount, specifier: "%.2f")")
                    .font(.subheadline)
                    .fontWeight(.semibold)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(Color.gray.opacity(0.05))
            .cornerRadius(8)
            .onTapGesture(perform: onTapped)
        }
    }
}

// MARK: - Missing Dashboard Components

public struct DashboardSubscriptionsSection: View {
    public let subscriptions: [Subscription]
    public let onSubscriptionTapped: (Subscription) -> Void
    public let onViewAllTapped: () -> Void
    public let onAddTapped: () -> Void
    
    public init(subscriptions: [Subscription], onSubscriptionTapped: @escaping (Subscription) -> Void, onViewAllTapped: @escaping () -> Void, onAddTapped: @escaping () -> Void) {
        self.subscriptions = subscriptions
        self.onSubscriptionTapped = onSubscriptionTapped
        self.onViewAllTapped = onViewAllTapped
        self.onAddTapped = onAddTapped
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Subscriptions")
                    .font(.headline)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button("View All") {
                    onViewAllTapped()
                }
                .font(.caption)
                .foregroundColor(.blue)
            }
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 12) {
                ForEach(subscriptions.isEmpty ? mockSubscriptions : subscriptions, id: \.id) { subscription in
                    SubscriptionCard(subscription: subscription) {
                        onSubscriptionTapped(subscription)
                    }
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
    
    private var mockSubscriptions: [Subscription] {
        [
            Subscription(name: "Netflix", amount: 15.99, billingCycle: .monthly, nextDueDate: Calendar.current.date(byAdding: .day, value: 5, to: Date()) ?? Date()),
            Subscription(name: "Spotify", amount: 9.99, billingCycle: .monthly, nextDueDate: Calendar.current.date(byAdding: .day, value: 10, to: Date()) ?? Date()),
            Subscription(name: "iCloud", amount: 2.99, billingCycle: .monthly, nextDueDate: Calendar.current.date(byAdding: .day, value: 15, to: Date()) ?? Date()),
            Subscription(name: "Adobe", amount: 19.99, billingCycle: .monthly, nextDueDate: Calendar.current.date(byAdding: .day, value: 20, to: Date()) ?? Date())
        ]
    }
    
    private struct SubscriptionCard: View {
        let subscription: Subscription
        let onTap: () -> Void
        
        var body: some View {
            VStack(spacing: 8) {
                Circle()
                    .fill(Color.blue)
                    .frame(width: 40, height: 40)
                    .overlay(
                        Image(systemName: "app")
                            .foregroundColor(.white)
                    )
                
                Text(subscription.name)
                    .font(.caption)
                    .fontWeight(.medium)
                
                Text("$\(subscription.amount, specifier: "%.2f")/mo")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .padding(12)
            .background(Color.gray.opacity(0.05))
            .cornerRadius(12)
            .onTapGesture(perform: onTap)
        }
    }
}

public struct DashboardBudgetProgress: View {
    public let budgets: [Budget]
    public let onBudgetTap: (Budget) -> Void
    public let onViewAllTap: () -> Void
    
    public init(budgets: [Budget], colorTheme: Any? = nil, themeComponents: Any? = nil, onBudgetTap: @escaping (Budget) -> Void, onViewAllTap: @escaping () -> Void) {
        self.budgets = budgets
        self.onBudgetTap = onBudgetTap
        self.onViewAllTap = onViewAllTap
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Budget Progress")
                    .font(.headline)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button("View All") {
                    onViewAllTap()
                }
                .font(.caption)
                .foregroundColor(.blue)
            }
            
            VStack(spacing: 12) {
                ForEach(budgets.isEmpty ? mockBudgets : budgets, id: \.id) { budget in
                    BudgetProgressRow(budget: budget) {
                        onBudgetTap(budget)
                    }
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
    
    private var mockBudgets: [Budget] {
        [
            Budget(name: "Food", limitAmount: 600, month: Date()),
            Budget(name: "Transport", limitAmount: 400, month: Date()),
            Budget(name: "Entertainment", limitAmount: 200, month: Date())
        ]
    }
    
    private struct BudgetProgressRow: View {
        let budget: Budget
        let onTap: () -> Void
        
        var body: some View {
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(budget.name)
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    Spacer()
                    
                    Text("$450 / $\(budget.limitAmount, specifier: "%.0f")")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                ProgressView(value: 0.75)
                    .progressViewStyle(LinearProgressViewStyle(tint: .blue))
                    .scaleEffect(x: 1, y: 0.5, anchor: .center)
            }
            .onTapGesture(perform: onTap)
        }
    }
}

public struct DashboardInsights: View {
    public let insights: [FinancialInsight]
    public let onDetailsTapped: () -> Void
    
    public init(insights: [FinancialInsight], onDetailsTapped: @escaping () -> Void) {
        self.insights = insights
        self.onDetailsTapped = onDetailsTapped
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Insights")
                    .font(.headline)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button("Details") {
                    onDetailsTapped()
                }
                .font(.caption)
                .foregroundColor(.blue)
            }
            
            VStack(spacing: 12) {
                ForEach(insights.isEmpty ? mockInsights : insights, id: \.id) { insight in
                    InsightRow(insight: insight)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
    
    private var mockInsights: [FinancialInsight] {
        [
            FinancialInsight(
                title: "Spending Tip",
                description: "You spent 15% less on dining this week!",
                priority: .medium,
                type: .spendingPattern,
                confidence: 0.9
            ),
            FinancialInsight(
                title: "Savings Goal",
                description: "You're on track to save $200 this month",
                priority: .high,
                type: .optimization,
                confidence: 0.8
            )
        ]
    }
    
    private struct InsightRow: View {
        let insight: FinancialInsight
        
        var body: some View {
            HStack(spacing: 12) {
                Image(systemName: iconForInsightType(insight.type))
                    .font(.system(size: 20))
                    .foregroundColor(colorForPriority(insight.priority))
                    .frame(width: 32, height: 32)
                    .background(colorForPriority(insight.priority).opacity(0.1))
                    .cornerRadius(8)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(insight.title)
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    Text(insight.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
            }
        }
        
        private func iconForInsightType(_ type: InsightType) -> String {
            switch type {
            case .spendingPattern: return "chart.line.uptrend.xyaxis"
            case .positiveSpendingTrend: return "arrow.down.circle"
            case .anomaly: return "exclamationmark.triangle"
            case .budgetAlert: return "chart.pie.fill"
            case .budgetInsight: return "chart.bar.fill"
            case .budgetRecommendation: return "plus.circle"
            case .subscriptionDetection: return "calendar.badge.clock"
            case .forecast: return "chart.xyaxis.line"
            case .optimization: return "bolt.circle"
            }
        }
        
        private func colorForPriority(_ priority: InsightPriority) -> Color {
            switch priority {
            case .low: return .green
            case .medium: return .blue
            case .high: return .orange
            case .urgent: return .red
            }
        }
    }
}

public struct DashboardQuickActions: View {
    public let onAddTransaction: () -> Void
    public let onPayBills: () -> Void
    public let onViewReports: () -> Void
    public let onSetGoals: () -> Void
    
    public init(onAddTransaction: @escaping () -> Void, onPayBills: @escaping () -> Void, onViewReports: @escaping () -> Void, onSetGoals: @escaping () -> Void) {
        self.onAddTransaction = onAddTransaction
        self.onPayBills = onPayBills
        self.onViewReports = onViewReports
        self.onSetGoals = onSetGoals
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Quick Actions")
                .font(.headline)
                .fontWeight(.semibold)
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible()),
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 12) {
                ActionButton(icon: "plus", title: "Add Transaction", color: .blue, action: onAddTransaction)
                ActionButton(icon: "creditcard", title: "Pay Bills", color: .orange, action: onPayBills)
                ActionButton(icon: "chart.bar", title: "View Reports", color: .green, action: onViewReports)
                ActionButton(icon: "target", title: "Set Goals", color: .purple, action: onSetGoals)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
    
    private struct ActionButton: View {
        let icon: String
        let title: String
        let color: Color
        let action: () -> Void
        
        var body: some View {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(.white)
                    .frame(width: 40, height: 40)
                    .background(color)
                    .cornerRadius(12)
                
                Text(title)
                    .font(.caption2)
                    .fontWeight(.medium)
                    .multilineTextAlignment(.center)
            }
            .onTapGesture(perform: action)
        }
    }
}

// MARK: - Additional Dashboard Components

public struct DashboardWelcomeHeader: View {
    public let greeting: String
    public let wellnessPercentage: Double
    public let totalBalance: Double
    public let monthlyIncome: Double
    public let monthlyExpenses: Double
    
    public init(colorTheme: Any? = nil, greeting: String, wellnessPercentage: Double, totalBalance: Double, monthlyIncome: Double, monthlyExpenses: Double) {
        self.greeting = greeting
        self.wellnessPercentage = wellnessPercentage
        self.totalBalance = totalBalance
        self.monthlyIncome = monthlyIncome
        self.monthlyExpenses = monthlyExpenses
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(greeting)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    Text("Financial Overview")
                        .font(.title2)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "bell")
                        .font(.system(size: 18))
                        .foregroundColor(.primary)
                        .frame(width: 40, height: 40)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(20)
                }
            }
            
            VStack(spacing: 8) {
                HStack {
                    Text("Total Balance")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Spacer()
                    Text(formatCurrency(totalBalance))
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                HStack {
                    Text("Monthly Income")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Spacer()
                    Text(formatCurrency(monthlyIncome))
                        .font(.subheadline)
                        .foregroundColor(.green)
                }
                
                HStack {
                    Text("Monthly Expenses")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Spacer()
                    Text(formatCurrency(monthlyExpenses))
                        .font(.subheadline)
                        .foregroundColor(.red)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
    
    private func formatCurrency(_ amount: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = "USD"
        return formatter.string(from: NSNumber(value: amount)) ?? "$0.00"
    }
}

public struct DashboardAccountsSummary: View {
    public let accounts: [FinancialAccount]
    public let onAccountTap: (String) -> Void
    public let onViewAllTap: () -> Void
    
    public init(accounts: [FinancialAccount], colorTheme: Any? = nil, themeComponents: Any? = nil, onAccountTap: @escaping (String) -> Void, onViewAllTap: @escaping () -> Void) {
        self.accounts = accounts
        self.onAccountTap = onAccountTap
        self.onViewAllTap = onViewAllTap
    }
    
    public var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Accounts")
                    .font(.headline)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button("View All") {
                    onViewAllTap()
                }
                .font(.caption)
                .foregroundColor(.blue)
            }
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 16) {
                    ForEach(accounts.isEmpty ? mockAccounts : accounts, id: \.id) { account in
                        AccountSummaryCard(account: account) {
                            onAccountTap(account.id.uuidString)
                        }
                    }
                }
                .padding(.horizontal)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
    
    private var mockAccounts: [FinancialAccount] {
        [
            FinancialAccount(name: "Checking", balance: 2450.00, iconName: "dollarsign.circle.fill", accountType: .checking),
            FinancialAccount(name: "Savings", balance: 15600.00, iconName: "banknote.fill", accountType: .savings),
            FinancialAccount(name: "Credit Card", balance: -1200.00, iconName: "creditcard.fill", accountType: .credit)
        ]
    }
    
    private struct AccountSummaryCard: View {
        let account: FinancialAccount
        let onTap: () -> Void
        
        var body: some View {
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Circle()
                        .fill(colorForAccountType(account.accountType))
                        .frame(width: 12, height: 12)
                    
                    Text(account.name)
                        .font(.caption)
                        .fontWeight(.medium)
                    
                    Spacer()
                }
                
                Text(formatCurrency(account.balance))
                    .font(.title3)
                    .fontWeight(.semibold)
                    .foregroundColor(account.balance < 0 ? .red : .primary)
            }
            .padding(12)
            .frame(width: 140)
            .background(Color.gray.opacity(0.05))
            .cornerRadius(12)
            .onTapGesture(perform: onTap)
        }
        
        private func colorForAccountType(_ type: AccountType) -> Color {
            switch type {
            case .checking: return .blue
            case .savings: return .green
            case .credit: return .orange
            case .investment: return .purple
            case .cash: return .yellow
            }
        }
        
        private func formatCurrency(_ amount: Double) -> String {
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            formatter.currencyCode = "USD"
            return formatter.string(from: NSNumber(value: amount)) ?? "$0.00"
        }
    }
}
